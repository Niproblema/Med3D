<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<input
<canvas id="canvas" width="1920" height="1080"></canvas>

<script src="../lib/three-math.min.js"></script>
<script src="../src/Med3D.js"></script>

<!-- LOADERS -->
<script src="../src/loaders/Cache.js"></script>
<script src="../src/loaders/LoadingManager.js"></script>
<script src="../src/loaders/XHRLoader.js"></script>
<script src="../src/loaders/ShaderLoader.js"></script>
<script src="../src/loaders/ObjLoader.js"></script>

<!-- CORE -->
<script src="../src/core/BufferAttribute.js"></script>
<script src="../src/core/GLAttributeManager.js"></script>
<script src="../src/core/GLManager.js"></script>
<script src="../src/core/Object3D.js"></script>
<script src="../src/core/Scene.js"></script>

<!-- CAMERA -->
<script src="../src/cameras/Camera.js"></script>
<script src="../src/cameras/PerspectiveCamera.js"></script>

<!-- LIGHTS -->
<script src="../src/lights/Light.js"></script>
<script src="../src/lights/AmbientLight.js"></script>
<script src="../src/lights/DirectionalLight.js"></script>
<script src="../src/lights/PointLight.js"></script>

<!-- MATERIALS -->
<script src="../src/materials/Material.js"></script>
<script src="../src/materials/MeshBasicMaterial.js"></script>
<script src="../src/materials/MeshPhongMaterial.js"></script>

<!-- OBJECTS -->
<script src="../src/objects/Geometry.js"></script>
<script src="../src/objects/Mesh.js"></script>

<!-- PROGRAM MANAGEMENT -->
<script src="../src/renderers/GLProgram.js"></script>
<script src="../src/renderers/GLProgramManager.js"></script>

<!-- RENDERS -->
<script src="../src/renderers/Renderer.js"></script>
<script src="../src/renderers/MeshRenderer.js"></script>

<script src="../src/marching_cubes/MarchingCubesTables.js"></script>
<script src="../src/marching_cubes/MarchingCubesWorker.js"></script>
<script src="../src/marching_cubes/MarchingCubes.js"></script>


<script>
    var mouseX = 0, mouseY = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var renderer = new M3D.MeshRenderer(document.getElementById("canvas"), M3D.WEBGL2);
    var aLight = new M3D.AmbientLight(new THREE.Color("#110000"), 1);
    var dLight = new M3D.DirectionalLight(new THREE.Color("#00FF00"), 1);
    var dLight2 = new M3D.DirectionalLight(new THREE.Color("#FF0000"), 1);
    var pLight = new M3D.PointLight(new THREE.Color("#0000FF"), 1);
    pLight.position.z = 1;
    dLight2.position = new THREE.Vector3(1, 0, 0);

    var scene = new M3D.Scene();
    scene.add(aLight);
    scene.add(dLight);
    scene.add(dLight2);
    scene.add(pLight);

    var camera = new M3D.PerspectiveCamera();

    camera.position.z = 30;
    camera.position.x = 0;
    camera.position.y = 0;

    renderer.addShaderLoaderUrls("../src/shaders");

    var manager = new M3D.LoadingManager();
    var loader = new M3D.ObjLoader(manager);

    var test = undefined;

    var mesh;


    init();
    function init() {
        fetchData({x: 200, y: 200, z: 200}, function(input) {
            var MC = new M3D.MarchingCubes();

            var start = new Date().getTime();

            MC.extractMesh(input.meta, input.values, 4, function(data) {

                var end = new Date().getTime();

                console.log("Marching cubes execution time: " + (end - start)/1000);

                var bufferGeometry = new M3D.Geometry();
                bufferGeometry.vertices = new M3D.BufferAttribute(new Float32Array(data), 3);
                bufferGeometry.computeVertexNormals();
                bufferGeometry.drawWireframe = false;

                mesh = new M3D.Mesh(bufferGeometry, new M3D.MeshPhongMaterial());
                mesh.rotateX(40);
                mesh.position.z = 0;
                mesh.material = new M3D.MeshPhongMaterial();
                mesh.material.specular = new THREE.Color("#999999");

                scene.add(mesh);


                animate();
            });
        });

        /*
        var positions = [];
        var values = [];

        // number of cubes along a side
        var size = {x: 100, y: 50, z: 100};
        var axisMin = -10;
        var axisMax = 10;
        var axisRange = axisMax - axisMin;

        // Generate a list of 3D positions and values
        for (var k = 0; k < size.z; k++) {
            for (var j = 0; j < size.y; j++) {
                for (var i = 0; i < size.x; i++) {
                    // actual values
                    var x = axisMin + axisRange * i / (size.x - 1);
                    var y = axisMin + axisRange * j / (size.y - 1);
                    var z = axisMin + axisRange * k / (size.z - 1);
                    positions.push(x, y, z);

                    //var value = (k === 10) ? -1 : 0;
                    //var value = (j > 5 && j < 30 && i > 5 && i < 20 && k > 5 && k < 10) ? -1 : 0;
                    //var value = x * x * x + y * y * z;
                    //var value = Math.sin(5 * x) * Math.cos(5* y) - Math.tan(10 * z);
                    var value = x * x + y * y - z * z - 25;
                    values.push(value);
                }
            }
        }
        */

    }

    function fetchData(dimensions, callback) {
        var worker = new Worker("MarchingCubesDataGenerator.js");

        worker.onmessage = function (result) {
            callback(result.data);
        };

        worker.postMessage([dimensions]);
    }


    function animate() {
        requestAnimationFrame(animate);

        camera.lookAt(mesh, new THREE.Vector3(0, 1, 0));
        pLight.position = camera.position;

        renderer.render(scene, camera);
    }


    var rotSpeed = .02;
    document.addEventListener('keydown', function(event) {
        var x = camera.position.x,
            y = camera.position.y,
            z = camera.position.z;

        if (event.keyCode === 65){
            mesh.rotateX(3.14159 / 32);
            //camera.position.x = x * Math.cos(rotSpeed) + z * Math.sin(rotSpeed);
            //camera.position.z = z * Math.cos(rotSpeed) - x * Math.sin(rotSpeed);
        } else if (event.keyCode === 68){
            mesh.rotateY(3.14159 / 32);
            //camera.position.x = x * Math.cos(rotSpeed) - z * Math.sin(rotSpeed);
            //camera.position.z = z * Math.cos(rotSpeed) + x * Math.sin(rotSpeed);
        } else if (event.keyCode === 87) {
            mesh.rotateY(3.14159 / 32)
        } else if (event.keyCode === 49) {
            mesh.geometry.drawWireframe = !mesh.geometry.drawWireframe;
        }
    });

</script>

</body>
</html>