<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<canvas id="canvas" width="1920" height="1080"></canvas>

<script src="../lib/three-math.min.js"></script>
<script src="../src/Med3D.js"></script>

<!-- LOADERS -->
<script src="../src/loaders/Cache.js"></script>
<script src="../src/loaders/LoadingManager.js"></script>
<script src="../src/loaders/XHRLoader.js"></script>
<script src="../src/loaders/ShaderLoader.js"></script>
<script src="../src/loaders/ObjLoader.js"></script>

<!-- CORE -->
<script src="../src/core/BufferAttribute.js"></script>
<script src="../src/core/GLAttributeManager.js"></script>
<script src="../src/core/GLManager.js"></script>
<script src="../src/core/Object3D.js"></script>
<script src="../src/core/Scene.js"></script>

<!-- CAMERA -->
<script src="../src/cameras/Camera.js"></script>
<script src="../src/cameras/PerspectiveCamera.js"></script>

<!-- LIGHTS -->
<script src="../src/lights/Light.js"></script>
<script src="../src/lights/AmbientLight.js"></script>
<script src="../src/lights/DirectionalLight.js"></script>
<script src="../src/lights/PointLight.js"></script>

<!-- MATERIALS -->
<script src="../src/materials/Material.js"></script>
<script src="../src/materials/MeshBasicMaterial.js"></script>
<script src="../src/materials/MeshPhongMaterial.js"></script>

<!-- OBJECTS -->
<script src="../src/objects/Geometry.js"></script>
<script src="../src/objects/Mesh.js"></script>

<!-- PROGRAM MANAGEMENT -->
<script src="../src/renderers/GLProgram.js"></script>
<script src="../src/renderers/GLProgramManager.js"></script>

<!-- RENDERS -->
<script src="../src/renderers/Renderer.js"></script>
<script src="../src/renderers/MeshRenderer.js"></script>

<script src="./MarchingCubesTables.js"></script>

<script>
    var mouseX = 0, mouseY = 0;

    var windowHalfX = window.innerWidth / 2;
    var windowHalfY = window.innerHeight / 2;

    var renderer = new M3D.MeshRenderer(document.getElementById("canvas"), M3D.WEBGL2);
    var aLight = new M3D.AmbientLight(new THREE.Color("#110000"), 1);
    var dLight = new M3D.DirectionalLight(new THREE.Color("#00FF00"), 1);
    var dLight2 = new M3D.DirectionalLight(new THREE.Color("#FF0000"), 1);
    var pLight = new M3D.PointLight(new THREE.Color("#0000FF"), 1);
    pLight.position.z = 1;
    dLight2.position = new THREE.Vector3(1, 0, 0);

    var scene = new M3D.Scene();
    scene.add(aLight);
    scene.add(dLight);
    scene.add(dLight2);
    scene.add(pLight);

    var camera = new M3D.PerspectiveCamera();

    camera.position.z = 50;
    camera.position.x = 0;
    camera.position.y = 0;

    renderer.addShaderLoaderUrls("../src/shaders");

    var manager = new M3D.LoadingManager();
    var loader = new M3D.ObjLoader(manager);

    var test = undefined;

    var mesh;
    init();
    function init() {
        var points = [];
        var values = [];

        // number of cubes along a side
        var size = 50;
        var axisMin = -10;
        var axisMax =  10;
        var axisRange = axisMax - axisMin;

        // Generate a list of 3D points and values at those points
        for (var k = 0; k < size; k++)
            for (var j = 0; j < size; j++)
                for (var i = 0; i < size; i++)
                {
                    // actual values
                    var x = axisMin + axisRange * i / (size - 1);
                    var y = axisMin + axisRange * j / (size - 1);
                    var z = axisMin + axisRange * k / (size - 1);
                    points.push( new THREE.Vector3(x, y, z) );
                    var value = x*x + y*y - z*z - 25;
                    values.push( value );
                }

        // Marching Cubes Algorithm

        var size2 = size * size;

        // Vertices may occur along edges of cube, when the values at the edge's endpoints
        //   straddle the isolevel value.
        // Actual position along edge weighted according to function values.
        var vlist = new Array(12);

        var vertexIndex = 0;
        var vertices = [];

        for (var z = 0; z < size - 1; z++)
            for (var y = 0; y < size - 1; y++)
                for (var x = 0; x < size - 1; x++)
                {
                    // index of base point, and also adjacent points on cube
                    var p    = x + size * y + size2 * z,
                            px   = p   + 1,
                            py   = p   + size,
                            pxy  = py  + 1,
                            pz   = p   + size2,
                            pxz  = px  + size2,
                            pyz  = py  + size2,
                            pxyz = pxy + size2;

                    // store scalar values corresponding to vertices
                    var value0 = values[ p ],
                            value1 = values[ px ],
                            value2 = values[ py ],
                            value3 = values[ pxy ],
                            value4 = values[ pz ],
                            value5 = values[ pxz ],
                            value6 = values[ pyz ],
                            value7 = values[ pxyz ];

                    // place a "1" in bit positions corresponding to vertices whose
                    //   isovalue is less than given constant.

                    var isolevel = 0;

                    var cubeindex = 0;
                    if ( value0 < isolevel ) cubeindex |= 1;
                    if ( value1 < isolevel ) cubeindex |= 2;
                    if ( value2 < isolevel ) cubeindex |= 8;
                    if ( value3 < isolevel ) cubeindex |= 4;
                    if ( value4 < isolevel ) cubeindex |= 16;
                    if ( value5 < isolevel ) cubeindex |= 32;
                    if ( value6 < isolevel ) cubeindex |= 128;
                    if ( value7 < isolevel ) cubeindex |= 64;

                    // bits = 12 bit number, indicates which edges are crossed by the isosurface
                    var bits = edgeTable[ cubeindex ];

                    // if none are crossed, proceed to next iteration
                    if ( bits === 0 ) continue;

                    // check which edges are crossed, and estimate the point location
                    //    using a weighted average of scalar values at edge endpoints.
                    // store the vertex in an array for use later.
                    var mu = 0.5;

                    // bottom of the cube
                    if ( bits & 1 )
                    {
                        mu = ( isolevel - value0 ) / ( value1 - value0 );
                        vlist[0] = points[p].clone().lerp( points[px], mu );
                    }
                    if ( bits & 2 )
                    {
                        mu = ( isolevel - value1 ) / ( value3 - value1 );
                        vlist[1] = points[px].clone().lerp( points[pxy], mu );
                    }
                    if ( bits & 4 )
                    {
                        mu = ( isolevel - value2 ) / ( value3 - value2 );
                        vlist[2] = points[py].clone().lerp( points[pxy], mu );
                    }
                    if ( bits & 8 )
                    {
                        mu = ( isolevel - value0 ) / ( value2 - value0 );
                        vlist[3] = points[p].clone().lerp( points[py], mu );
                    }
                    // top of the cube
                    if ( bits & 16 )
                    {
                        mu = ( isolevel - value4 ) / ( value5 - value4 );
                        vlist[4] = points[pz].clone().lerp( points[pxz], mu );
                    }
                    if ( bits & 32 )
                    {
                        mu = ( isolevel - value5 ) / ( value7 - value5 );
                        vlist[5] = points[pxz].clone().lerp( points[pxyz], mu );
                    }
                    if ( bits & 64 )
                    {
                        mu = ( isolevel - value6 ) / ( value7 - value6 );
                        vlist[6] = points[pyz].clone().lerp( points[pxyz], mu );
                    }
                    if ( bits & 128 )
                    {
                        mu = ( isolevel - value4 ) / ( value6 - value4 );
                        vlist[7] = points[pz].clone().lerp( points[pyz], mu );
                    }
                    // vertical lines of the cube
                    if ( bits & 256 )
                    {
                        mu = ( isolevel - value0 ) / ( value4 - value0 );
                        vlist[8] = points[p].clone().lerp( points[pz], mu );
                    }
                    if ( bits & 512 )
                    {
                        mu = ( isolevel - value1 ) / ( value5 - value1 );
                        vlist[9] = points[px].clone().lerp( points[pxz], mu );
                    }
                    if ( bits & 1024 )
                    {
                        mu = ( isolevel - value3 ) / ( value7 - value3 );
                        vlist[10] = points[pxy].clone().lerp( points[pxyz], mu );
                    }
                    if ( bits & 2048 )
                    {
                        mu = ( isolevel - value2 ) / ( value6 - value2 );
                        vlist[11] = points[py].clone().lerp( points[pyz], mu );
                    }

                    // construct triangles -- get correct vertices from triTable.
                    var i = 0;
                    cubeindex <<= 4;  // multiply by 16...
                    // "Re-purpose cubeindex into an offset into triTable."
                    //  since each row really isn't a row.

                    // the while loop should run at most 5 times,
                    //   since the 16th entry in each row is a -1.
                    while (triTable[ cubeindex + i ] != -1 )
                    {
                        var index1 = triTable[cubeindex + i];
                        var index2 = triTable[cubeindex + i + 1];
                        var index3 = triTable[cubeindex + i + 2];

                        vertices.push(vlist[index1].x/100);
                        vertices.push(vlist[index1].y/100);
                        vertices.push(vlist[index1].z/100);
                        vertices.push(vlist[index2].x/100);
                        vertices.push(vlist[index2].y/100);
                        vertices.push(vlist[index2].z/100);
                        vertices.push(vlist[index3].x/100);
                        vertices.push(vlist[index3].y/100);
                        vertices.push(vlist[index3].z/100);

                        vertexIndex += 3;
                        i += 3;
                    }
                }

        var bufferGeometry = new M3D.Geometry();
        bufferGeometry.vertices = new M3D.BufferAttribute(new Float32Array(vertices), 3);
        bufferGeometry.computeVertexNormals();

        mesh = new M3D.Mesh(bufferGeometry, new M3D.MeshPhongMaterial());
        mesh.rotateX(40);
        mesh.position.z = 0;
        mesh.material = new M3D.MeshPhongMaterial();
        mesh.material.specular = new THREE.Color("#999999");

        scene.add(mesh);


        animate();
    }


    function animate() {
        requestAnimationFrame(animate);

        camera.lookAt(mesh, new THREE.Vector3(0, 1, 0));
        pLight.position = camera.position;

        renderer.render(scene, camera);
    }


    var rotSpeed = .02;
    document.addEventListener('keydown', function(event) {
        var x = camera.position.x,
                y = camera.position.y,
                z = camera.position.z;

        if (event.keyCode === 65){
            mesh.rotateX(3.14159 / 32);
            //camera.position.x = x * Math.cos(rotSpeed) + z * Math.sin(rotSpeed);
            //camera.position.z = z * Math.cos(rotSpeed) - x * Math.sin(rotSpeed);
        } else if (event.keyCode === 68){
            mesh.rotateY(3.14159 / 32);
            //camera.position.x = x * Math.cos(rotSpeed) - z * Math.sin(rotSpeed);
            //camera.position.z = z * Math.cos(rotSpeed) + x * Math.sin(rotSpeed);
        } else if (event.keyCode == 87) {
            mesh.rotateY(3.14159 / 32)
        }
    });

</script>

</body>
</html>